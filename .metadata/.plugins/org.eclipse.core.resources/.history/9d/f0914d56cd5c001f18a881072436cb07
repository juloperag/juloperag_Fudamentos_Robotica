/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Semaphore
 ******************************************************************************
 */

//Incluir archivo punto h para el main
#include "main.h"

//---------------------------Inicio de definicion de funciones y variables base----------------------------------
GPIO_Handler_t handler_GPIO_BlinkyPin = {0};    //Definimos un elemento del tipo GPIO_Handler_t (Struct) para el LED
void initSystem(void);                          //Definimos la cabecera para la configuracion
//---------------------------Fin de definicion de funciones y variables base----------------------------------

//--------------------------EXTI-------------------------------
GPIO_Handler_t handler_GPIO_Button = {0};     //Definicion un elemento del tipo EXTI_Config_t y PIO_Handler_t para el user boton
EXTI_Config_t handler_EXTI_Button ={0};

//--------------------------USART-------------------------------
GPIO_Handler_t handler_GPIO_CommTerm_TX = {0};       //Definimos un elemento del tipo GPIO_Handler_t (Struct) y USART_Handler_t para el uso del USB
GPIO_Handler_t handler_GPIO_CommTerm_RX = {0};
USART_Handler_t handler_USART_CommTerm = {0};
char usartData = 'w';                                //Variable que almacena el caracter leido

//-------------------------FreeRTOS-----------------------------------
//Definicion de variables para la configuracion inicial del FreeRTOS
uint32_t SystemCoreClock = 100E6;
#define STACK_SIZE 200
//Variable para comprobar la creacion de los elementos
BaseType_t xReturned;

//Cabeceras de las funciones de las Tareas
extern void vTask_Test_counting(void * pvParameters);
extern void vTask_Print(void * pvParameters);
//Handler de las Tareas
TaskHandle_t xHandleTask_Counting = NULL;
TaskHandle_t xHandleTask_Print = NULL;

//Handler de las Queue
QueueHandle_t xQueue_Print;

//Handler de los semaphores
SemaphoreHandle_t xBinarySemaphore_Working;
SemaphoreHandle_t xCountingSemaphore_Working;

//Handler para el Software Timer
TimerHandle_t xHandlerTimer_Led;
//Cabecera de la funcion del Software Timer
extern void led_state_callback(TimerHandle_t xTimer);

//--------------Variables y funciones adicionales-----------------
//-----Definicion de funciones
uint16_t getRandomNumber(void);
//------Definicion de variables
volatile uint8_t printOneTime = 0;
volatile uint16_t randomNumber = 0;

int main(void)
{
	//Incrementamos la velocidad de reloj del sistema
	uint8_t clock = CLOCK_SPEED_100MHZ;    //Velocidad de reloj entre 25 o 100 MHz
	configPLL(clock);
	//Configuracion inicial del sistema
	initSystem();
	//Activamos la unidad de punto flotante (FPU)
	SCB->CPACR    |= (0xF << 20);
	//Activamos del contador de Ticks
	DWT->CTRL    |= (1 << 0);

	//-----------------------Inicio cofiguracion de los elemntos del kernel de FreeRTOS----------------------

	//-------------------Configuracion Task--------------
	//Tarea Counting
	xReturned = xTaskCreate(
						vTask_Test_counting,  /* Function that implements the task. */
	                    "Task_Counting",      /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						NULL,    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask_Counting);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);
	//Tarea Print
	xReturned = xTaskCreate(
						vTask_Print,       /* Function that implements the task. */
	                    "Task_Print",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						NULL,    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask_Print);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);


	//-------------------Configuracion Queue--------------
	//cola para enviar datos por consola
	xQueue_Print = xQueueCreate(10, sizeof( size_t) );
	configASSERT(xQueue_Print != NULL);

	//-------------------Configuracion Semaphore-------------
	//Semaphore que indica los working a realizar, Binario o Counting
	//xBinarySemaphore_Working = xSemaphoreCreateBinary();
	xCountingSemaphore_Working = xSemaphoreCreateCounting(10,0);

	//-------------------Configuracion Timer--------------
	//Software Timer para el blink
	xHandlerTimer_Led = xTimerCreate("led_timer", pdMS_TO_TICKS(350), pdTRUE, 0, led_state_callback);
	xTimerStart(xHandlerTimer_Led, portMAX_DELAY);

	//-------------------Inicializacion Scheduler--------------
	//Inicia le Scheduler a funcionar
	vTaskStartScheduler();

	//-----------------------Fin cofiguracion de los elemntos del kernel de FreeRTOS----------------------

	//Si el scheduler se inicia correctamente no se ejecutada este while
	while(1)
	{
		__NOP();
	}
}


//------------------------------Inicio Configuracion del microcontrolador------------------------------------------
void initSystem(void)
{
	//---------------------------------Inicio de Configuracion GPIOx---------------------------------

	//---------------------------BlinkyLed--------------------------------
	//---------------PIN: PA5----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_BlinkyPin.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_BlinkyPin.GPIO_PinConfig.GPIO_PinNumber = PIN_5; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_BlinkyPin, GPIO_MODE_OUT, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_BlinkyPin);

	//---------------------------USART--------------------------------
	//---------------PIN: PA2----------------
	//------------AF7: USART2_TX----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_CommTerm_TX.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_CommTerm_TX.GPIO_PinConfig.GPIO_PinNumber = PIN_2; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_CommTerm_TX, GPIO_MODE_ALTFN, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF7);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_CommTerm_TX);

	//---------------PIN: PA3----------------
	//------------AF7: USART2_RX----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_CommTerm_RX.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_CommTerm_RX.GPIO_PinConfig.GPIO_PinNumber = PIN_3; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_CommTerm_RX, GPIO_MODE_ALTFN, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF7);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_CommTerm_RX);


	//---------------------------------Fin de Configuracion GPIOx---------------------------------


	//-------------------Inicio de Configuracion USARTx-----------------------

	//---------------USART2----------------
	//Definimos el periferico USARTx a utilizar
	handler_USART_CommTerm.ptrUSARTx = USART2;
	//Definimos la configuracion del USART seleccionado
	handler_USART_CommTerm.USART_Config.USART_mode = USART_MODE_TX;           //USART_MODE_x  x-> TX, RX, RXTX, DISABLE
	handler_USART_CommTerm.USART_Config.USART_baudrate = USART_BAUDRATE_115200;  //USART_BAUDRATE_x  x->9600, 19200, 115200
	handler_USART_CommTerm.USART_Config.USART_parity= USART_PARITY_NONE;       //USART_PARITY_x   x->NONE, ODD, EVEN
	handler_USART_CommTerm.USART_Config.USART_stopbits=USART_STOPBIT_1;         //USART_STOPBIT_x  x->1, 0_5, 2, 1_5
	handler_USART_CommTerm.USART_Config.USART_enableIntRX = USART_RX_INTERRUP_DISABLE;   //USART_RX_INTERRUP_x  x-> DISABLE, ENABLE
	handler_USART_CommTerm.USART_Config.USART_enableIntTX = USART_TX_INTERRUP_DISABLE;   //USART_TX_INTERRUP_x  x-> DISABLE, ENABLE
	//Cargamos la configuracion del USART especifico
	USART_Config(&handler_USART_CommTerm);

	//-------------------Fin de Configuracion USARTx-----------------------


	//-------------------Inicio de Configuracion EXTIx -----------------------

	//---------------PIN: PC13----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_Button.pGPIOx = GPIOC;
	//Definimos el pin a utilizar
	handler_GPIO_Button.GPIO_PinConfig.GPIO_PinNumber = PIN_13;
	//Definimos la posicion del elemento pGIOHandler.
	handler_EXTI_Button.pGPIOHandler = &handler_GPIO_Button;
	//Definimos el tipo de flanco
	handler_EXTI_Button.edgeType = EXTERNAL_INTERRUPP_FALLING_EDGE;
	//Cargamos la configuracion del EXTIx
	extInt_Config(&handler_EXTI_Button);

	//-------------------Fin de Configuracion EXTIx-----------------------

}

//------------------------------Fin Configuracion del microcontrolador------------------------------------------



//----------------------------Inicio de la definicion de las funciones ISR---------------------------------------

//-------------------------UserButton--------------------------------
//Definimos la funcion que se desea ejecutar cuando se genera la interrupcion por el EXTI13
void callback_extInt13(void)
{
	/* Activar la variable printOneTime*/
	printOneTime = 1;
	/* Generar un numero aleatorio */
	randomNumber = getRandomNumber();

	BaseType_t pxHigherPriorityTaskWoken;
	pxHigherPriorityTaskWoken = pdFALSE;

	/* Hacer un for que se ejecute tantas veces como el numero aleatorio lo indica
	 * y allí cargar el semaforo (ejemplo binario y ejemplo counter)*/
   	for (uint16_t ii = 0; ii < randomNumber; ii++) {
   		/*cargar el semaforo e indicar que hay un cambio en las funciones.*/
   		xSemaphoreGiveFromISR(xCountingSemaphore_Working, &pxHigherPriorityTaskWoken);
	}
   	//Realizamos cambio de contexto
   	portYIELD_FROM_ISR(pxHigherPriorityTaskWoken);
}

//----------------------------Fin de la definicion de las funciones ISR----------------------------------------


//-------------------------Inicio definicion funciones Adicionales----------------

//Generamos un numero Ramdom
uint16_t getRandomNumber(void)
{
	srand( xTaskGetTickCount() );
	int randomnumber;
	randomnumber = (rand() % 10) +1;
	return (uint16_t)randomnumber;
}
//-------------------------Fin definicion funciones Adicionales----------------


