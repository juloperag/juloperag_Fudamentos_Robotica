/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 */

//----------------------Librerias---------------------------------
//Sistema
#include "stdio.h"
#include <stdint.h>
//FreeRTOS
#include "FreeRTOS.h"
#include "task.h"
//CMSIS
#include <stm32f411xe.h>
//PeripheralDrivers
#include <GPIOxDriver.h>
#include <PLLDriver.h>

//---------------------------Inicio de definicion de funciones y variables base----------------------------------

GPIO_Handler_t handler_GPIO_BlinkyPin = {0};    //Definimos un elemento del tipo GPIO_Handler_t (Struct) para el LED
void initSystem(void);                          //Definimos la cabecera para la configuracion

//---------------------------Fin de definicion de funciones y variables base----------------------------------

//-------------------------PIN MCO1--------------------------------
GPIO_Handler_t handler_GPIO_MCO1 = {0};       //Definimos un elemento del tipo GPIO_Handler_t (Struct) para utilizar el pin MCO1 con el fin de muestrear las frecuencias de los osciladores

//-------------------------Button---------------------------
GPIO_Handler_t handler_GPIO_Button = {0};    //Definimos un elemento del tipo GPIO_Handler_t (Struct) para el boton

//-------------------------SEGGER-----------------------------------
extern void SEGGER_UART_init(uint32_t);     //Le indicamos al sistema que hay una funcion para inicio de la comunicacion del SEGGER por UART

//-------------------------FreeRTOS-----------------------------------
//Definicion de variables del sistema
uint32_t SystemCoreClock = 100E6;
//Variables del programa
#define STACK_SIZE 200
//Cabeceras de las tareas y sus handlers
void vTask_blink_led(void * pvParameters );
void vTaskTwo(void * pvParameters );
//Handler de las tareas
TaskHandle_t xHandleTask1 = NULL;
TaskHandle_t xHandleTask2 = NULL;
//Variable para comprobar la creacion de la tarea
BaseType_t xReturned;

int main(void)
{
	//Incrementamos la velocidad de reloj del sistema
	uint8_t clock = CLOCK_SPEED_100MHZ;    //Velocidad de reloj entre 25 o 100 MHz
	configPLL(clock);
	//Configuracion inicial del sistema
	initSystem();
	//Activamos la unidad de punto flotante (FPU)
	SCB->CPACR    |= (0xF << 20);
	//Activamos del contador de Ticks
	DWT->CTRL    |= (1 << 0);

	//---------------------Inicio de uso de funciones para el funcionamiento del SEGGER----------------------
	//Necesaria para el SEGGER
	vInitPrioGroupValue();
	//Configuramos el puerto Serial para trabajar  con el SEGGER
	SEGGER_UART_init(500000);
	/* Primero configuramos */
	SEGGER_SYSVIEW_Conf();
	/* Despues activamos el sistema */
	//SEGGER_SYSVIEW_Start();
	//-----------------------Fin de uso de funciones para el funcionamiento del SEGGER----------------------

	//-----------------------Fin de uso de funciones para el funcionamiento del SEGGER----------------------

	//Configuracion tarea 1
	xReturned = xTaskCreate(
						vTask_blink_led,       /* Function that implements the task. */
	                    "Task1",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						"Blinky",    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask1);      /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

	//configuracion tarea 2
	xReturned = xTaskCreate(
						vTaskTwo,       /* Function that implements the task. */
	                    "Task2",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						"Hola Mundo desde la tarea-2",    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask2);      /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

	/* Start the created tasks running. */
	vTaskStartScheduler();

	//-----------------------Fin de uso de funciones para el funcionamiento del SEGGER----------------------

	//Si el scheduler se inicia correctamente no se ejecutada este while
	while(1)
	{
		__NOP();
	}
}

//Funcion para definir la configuracion inicial del sistema
void initSystem(void)
{
	//---------------------------BlinkyLed--------------------------------
	//---------------PIN: PA5----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_BlinkyPin.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_BlinkyPin.GPIO_PinConfig.GPIO_PinNumber = PIN_5; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_BlinkyPin, GPIO_MODE_OUT, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_BlinkyPin);

	//---------------------------Button-------------------------------
	//---------------PIN: PC13----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_Button.pGPIOx = GPIOC;
	//Definimos el pin a utilizar
	handler_GPIO_Button.GPIO_PinConfig.GPIO_PinNumber = PIN_13; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_Button, GPIO_MODE_OUT, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_Button);

	//-------------------------PIN_MCO1--------------------------------
	//---------------PIN: PA8----------------
	//------------AF0: MCO_1----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_MCO1.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_MCO1.GPIO_PinConfig.GPIO_PinNumber = PIN_8; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_MCO1, GPIO_MODE_ALTFN, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_MCO1);

}

/* Funcion que gobierna a la tarea 1*/
void vTask_blink_led( void * pvParameters )
{
	 BaseType_t notify_state = 0;
	 uint8_t change_state = 0;

	while(1)
	{
		if(notify_state == pdTRUE)
		{
			change_state = !change_state;
		}
		if(change_state == 1)
		{
			GPIOxTooglePin(&handler_GPIO_BlinkyPin);
		}
		else
		{
			GPIO_writePin(&handler_GPIO_BlinkyPin, RESET);
		}

		notify_state = xTaskNotifyWait(0,
		                           	   0,
									   NULL,
									   pdMS_TO_TICKS(250));
		//vTaskDelayUntil(&xHandleTask1, pdMS_TO_TICKS(250));
	}
}

/* Funcion que gobierna a la tarea 2*/
void vTaskTwo( void * pvParameters )
{
	int8_t button_state = 0;
	uint8_t prev_button_state = 0;
	while(1)
	{
		button_state =  GPIO_RedPin (&handler_GPIO_Button);
		if(button_state==1)
		{
			if(!prev_button_state)
			{
				xTaskNotify(xHandleTask1,0,eNoAction);
			}
		}

		prev_button_state = button_state;

		vTaskDelay(pdMS_TO_TICKS(10));
	}
}

