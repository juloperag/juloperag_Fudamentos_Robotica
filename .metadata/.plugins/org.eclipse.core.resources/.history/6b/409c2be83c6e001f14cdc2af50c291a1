/*
 * task_handler.c
 *
 *  Created on: Aug 7, 2024
 *      Author: julil
 */


#include "main.h"

//-----Cabeceras de funciones para los motores----------
void config_motor(uint8_t status, int firth, float second, float third);
void status_motor(uint8_t status);
void PID_simple(Parameters_PID_t *ptrPIDHandler, float timer, float setpoint, float measure);
void correction(Motor_Handler_t *ptrMotorHandler);
void init_coordinates(void);
//----Cabeceras de funciones para el control de los modos------
void straight_line(uint8_t dutty);
void config_mode(uint8_t status, float dutty_L, float dutty_R);
//-----Cabeceras de funciones de los comandos--------
void process_command(char cmd[20]);
int extract_command(char cmd[20]);
//------------------Variables---------------------
//---------mensajes----------
const char *msg_com_invalid = "Comando invalido  \n";
//-------Odometria-------------
Parameters_Path_t parameter_Path_Robot = {0};           //Estructura que almacena los parametros del camino a recorrer


//-----------------------Inicio definicion funciones de las Task---------------------------
//------Tarea Menu-------
void vTask_Menu(void * pvParameters)
{
	//Variables para la recepcion
	uint32_t cmd_addr;
	//Variables de la separacin
	char cmd[20]= {0};
	int firtsParameter = 0;
	int secondParameter = 0;

	//Mensaje inicial del menu
	const char* msg_menu = "=======================\n"
			               "|         Menu        |\n"
						   "=======================\n"
						   "go ---> inicia \n";

	while(1)
	{
		if(next_state == sMainMenu){ xQueueSend(xQueue_Print, &msg_menu, portMAX_DELAY); }
		//Se espera por el comando a ejecutar
		xTaskNotifyWait(0,0,&cmd_addr, portMAX_DELAY);
		//Funcion que lee la cadena de caracteres y la divide en los elementos definidos
		sscanf((char* ) cmd_addr, "%s %u %u", cmd, &firtsParameter, &secondParameter);

		//Se verificamos si se tiene un solo caracter
		if(strcmp(cmd, "go") == 0)
		{
			//Notificamos a la tarea respectiva
			//xTaskNotify(xHandleTask_Go, (uint32_t) firtsParameter, eSetValueWithoutOverwrite);
			xTaskNotify(xHandleTask_Go, 0, eNoAction);
			//Cambio de state
			next_state = sGo;
		}
		else
		{
			//Se envia la opcion especificada
			xQueueSend(xQueue_Print, &msg_com_invalid, portMAX_DELAY);
			/*Se envia una notificacion previa con la finalidad de desbloquear
			 la tarea, la cual se bloquea para que se envie el mensaje por USART*/
			xTaskNotify(xHandleTask_Menu, 0, eNoAction);
			xTaskNotifyWait(0,0,NULL, portMAX_DELAY);
		}
	}

}

//-------Tarea de Imprimir-------
void vTask_Print(void * pvParameters)
{
	//Variable para guardad mensaje a enviar
	uint32_t *msg;

	while(1)
	{
		//Se espera por el puntero del mensaje
		xQueueReceive(xQueue_Print, &msg, portMAX_DELAY);
		//Enviamos por puerto serial dicho mensaje
		writeMsg(&handler_USART_CommTerm, (char *) msg);
	}
}

//-------Tarea de los comando-------
void vTask_Commands(void * pvParameters)
{
	BaseType_t notify_status = {0};
	char cmd[20];

	while(1)
	{
		//Se espera por la notificacion de la interrupcion
		notify_status = xTaskNotifyWait(0,0,NULL,portMAX_DELAY);
		//Si es verdadero se recibe una notificacion
		if(notify_status == pdTRUE)
		{
			//Se procesa el comando recibido
			process_command(cmd);
		}
	}
}

//------------Tarea Go---------------
void vTask_Go(void * pvParameters)
{
	//Definicion de variable de notificacion
	BaseType_t notify_status = {0};

	while(1)
	{
		//Se espera por la notificacion de la interrupcion
		notify_status = xTaskNotifyWait(0,0,NULL,portMAX_DELAY);
		//Si es verdadero se recibe una notificacion
		if(notify_status == pdTRUE)
		{
			//Restablecimiento de coordenadas
			init_coordinates();
			//Definicion de parametros
			change_position(&parameter_Path_Robot, 3000);
			//Configuracion inicial linea recta
			straight_line(duttySetPoint);
		}
	}

}
//-----------------------Fin definicion funciones de las Task---------------------------



//-----------------------Inicio definicion funciones del Software Timer---------------------------

void led_state_callback(TimerHandle_t xTimer)
{
	//Cambio estado opuesto Led
	GPIOxTooglePin(&handler_GPIO_BlinkyPin);
}

//-----------------------Fin Definicion Funciones del Software Timer---------------------------



//-----------------------Inicio definicion funciones para la comunicacion---------------------------

//Funcion que ayuda en el procesamiento del comando
void process_command(char cmd[20])
{
	extract_command(cmd);

	switch(next_state)
	{
	case sMainMenu:
		//Notificamos a la tarea respectiva
		xTaskNotify(xHandleTask_Menu, (uint32_t) cmd, eSetValueWithoutOverwrite);
		break;
	case sGo:
		//xTaskNotify(xHandleTask_Rtc, (uint32_t) cmd, eSetValueWithoutOverwrite);
		break;
	default:
		__NOP();
		break;
	}
}
//Funcion para obtener el comando
int extract_command(char cmd[20])
{
	//Definicion de variables
	uint8_t item;
	uint8_t counter_j = 0;
	BaseType_t status;
	//Se verifica si hay un nuevo mensaje
	status = uxQueueMessagesWaiting(xQueue_InputData);
	if(status == 0)
	{
		return -1;
	}
	do{
		//Recibimos un elemento y lo montamos en item
		status = xQueueReceive(xQueue_InputData, &item, 0);
		if(status ==pdTRUE){
			//Vamos llenando el arreglo del comando
			cmd[counter_j++] = item;
		}
	}while(item != '#');

	//Agregamos el elemento nulo y ademas definimos el largo del mensaje
	cmd[counter_j - 1] = '\0';

	return 0;
}

//-----------------------Fin definicion funciones para la comunicacion---------------------------




//------------------------------Inicio de la definicion de funciones del modo----------------------------------------
//------linea recta------
void straight_line(uint8_t dutty)   //a = [mm]
{
	//---------Calculo parametros de la linea recta---------
	calculation_parameter_distance(&parameter_Path_Robot);
	//---------Configuracion coordenadas medidas---------
	//Coordenadas Globales
	parameter_Posicion_Robot.grad_grobal += ang_complementary;
	//Reiniciaos Coordenadas relativas
	parameter_Posicion_Robot.xr_position = parameter_Posicion_Robot.yr_position = 0;
	parameter_Posicion_Robot.phi_relativo = 0;
	parameter_Posicion_Robot.grad_relativo = 0;
	ang_for_Displament_ICR = 0;
	//---------Configuracion coordenadas teoricas---------
	parameter_Path_Robot.rotative_Grad_Relative = 0;
	//Calculos extra
	cos_cal = cos(((parameter_Posicion_Robot.grad_grobal*M_PI)/180));
	sin_cal = sin(((parameter_Posicion_Robot.grad_grobal*M_PI)/180));
	//-----------------PID-------------------------
	//Establecemos valores iniciales
	handler_Motor_L.parametersMotor.parametersPID.e = handler_Motor_L.parametersMotor.parametersPID.e_prev = 0;
	handler_Motor_L.parametersMotor.parametersPID.u =  handler_Motor_L.parametersMotor.parametersPID.e_intel = 0;
	handler_Motor_R.parametersMotor.parametersPID.e = handler_Motor_R.parametersMotor.parametersPID.e_prev = 0;
	handler_Motor_R.parametersMotor.parametersPID.u =  handler_Motor_R.parametersMotor.parametersPID.e_intel = 0;
	parameter_PID_distace.e = parameter_PID_distace.e_prev = parameter_PID_distace.u =  parameter_PID_distace.e_intel = 0;
	//-------------Configruacion Modo--------------
	//Definimos el dutty inicial
	handler_Motor_L.configMotor.new_dutty = duttySetPoint;
	handler_Motor_R.configMotor.new_dutty = duttySetPoint;
	//Reiniciamos variables
	time_accumulated = counting_action = flag_action = 0;
	//Cargamos la configuracion del modo e iniciamos el modo
	config_mode(1, dutty, dutty);
}


void config_mode(uint8_t status, float dutty_L, float dutty_R)
{
	//Cargamos la configuracion
	config_motor(status, dutty_L, dutty_R, frequency_PWM_Motor); //Tipo de Estudio, por dutty L, por dutty R, fre pwm [hz]
	//Iniciamos los motores
	status_motor(SET);
	//Medimos el tiempo inicial
	sample_Gyro.timer_prev = getTicksMs();
}

void init_coordinates(void)
{
	//Reinicio de varibable
	ang_for_Displament_ICR = 0;
	ang_complementary = 0;
	//Reinicio de parametros de la structura de la posicion del robot
	parameter_Posicion_Robot.grad_grobal = 0; parameter_Posicion_Robot.grad_relativo = 0; parameter_Posicion_Robot.phi_relativo = 0;
	parameter_Posicion_Robot.xg_position = 0; parameter_Posicion_Robot.xg_position_inicial = 0; parameter_Posicion_Robot.xr_position = 0;
	parameter_Posicion_Robot.yg_position = 0; parameter_Posicion_Robot.yg_position_inicial = 0; parameter_Posicion_Robot.yr_position = 0;
	//Reinicio de parametros de la structura de path
	parameter_Path_Robot.goal_Position_x = 0; parameter_Path_Robot.goal_Position_y = 0;
	parameter_Path_Robot.line_Distance = 0;
	parameter_Path_Robot.rotative_Grad = 0; parameter_Path_Robot.rotative_Grad_Relative = 0;
	parameter_Path_Robot.start_position_x = 0; parameter_Path_Robot.start_position_y = 0;
}

//-----------------------------Fin de la definicio de funciones del modo--------------------------------------------



