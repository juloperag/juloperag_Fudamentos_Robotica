/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 */

//----------------------Librerias---------------------------------
//Sistema
#include "stdio.h"
#include <stdint.h>
//FreeRTOS
#include "FreeRTOS.h"
#include "task.h"
//CMSIS
#include <stm32f411xe.h>
//PeripheralDrivers
#include <GPIOxDriver.h>
#include <PLLDriver.h>

//---------------------------Inicio de definicion de funciones y variables base----------------------------------
GPIO_Handler_t handler_GPIO_BlinkyPin = {0};    //Definimos un elemento del tipo GPIO_Handler_t (Struct) para el LED
void initSystem(void);                          //Definimos la cabecera para la configuracion
//---------------------------Fin de definicion de funciones y variables base----------------------------------

//-------------------------PIN MCO2--------------------------------
GPIO_Handler_t handler_GPIO_MCO2 = {0};       //Definimos un elemento del tipo GPIO_Handler_t (Struct) para utilizar el pin MCO2 con el fin de muestrear las frecuencias de los osciladores

//-------------------------Button---------------------------
GPIO_Handler_t handler_GPIO_Button = {0};    //Definimos un elemento del tipo GPIO_Handler_t (Struct) para el boton

//-------------------------SEGGER-----------------------------------
extern void SEGGER_UART_init(uint32_t);     //Le indicamos al sistema que hay una funcion para inicio de la comunicacion del SEGGER por UART

//-------------------------FreeRTOS-----------------------------------
//Definicion de variables para la configuracion inicial del FreeRTOS
uint32_t SystemCoreClock = 100E6;
#define STACK_SIZE 200
//Handler de las Tareas
TaskHandle_t xHandleTaskBL = NULL;
TaskHandle_t xHandleTask2 = NULL;
//Handler de las funciones de las Tareas
void vTask_blink_led(void * pvParameters);
void vTaskTwo(void * pvParameters);
//Variable para comprobar la creacion de la tarea
BaseType_t xReturned;

int main(void)
{
	//Incrementamos la velocidad de reloj del sistema
	uint8_t clock = CLOCK_SPEED_100MHZ;    //Velocidad de reloj entre 25 o 100 MHz
	configPLL(clock);
	//Configuracion inicial del sistema
	initSystem();
	//Activamos la unidad de punto flotante (FPU)
	SCB->CPACR    |= (0xF << 20);
	//Activamos del contador de Ticks
	DWT->CTRL    |= (1 << 0);

	//---------------------Inicio de uso de funciones para el funcionamiento del SEGGER----------------------
	//Necesaria para el SEGGER
	vInitPrioGroupValue();
	//Configuramos el puerto Serial para trabajar  con el SEGGER
	SEGGER_UART_init(500000);
	/* Primero configuramos */
	SEGGER_SYSVIEW_Conf();
	//-----------------------Fin de uso de funciones para el funcionamiento del SEGGER----------------------

	//-----------------------Inicio cofiguracion de los elemntos del kernel de FreeRTOS----------------------

	//-------------------Configuracion tarea 1--------------
	xReturned = xTaskCreate(
						vTask_blink_led,       /* Function that implements the task. */
	                    "Task1",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						"Blinky",    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTaskBL);      /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

	//-------------------Configuracion tarea 2--------------
	xReturned = xTaskCreate(
						vTaskTwo,       /* Function that implements the task. */
	                    "Task2",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						"Hola Mundo desde la tarea-2",    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask2);      /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

	//-------------------Inicializacion Scheduler--------------
	vTaskStartScheduler();

	//-----------------------Fin cofiguracion de los elemntos del kernel de FreeRTOS----------------------

	//Si el scheduler se inicia correctamente no se ejecutada este while
	while(1)
	{
		__NOP();
	}
}


//------------------------------Inicio Configuracion del microcontrolador------------------------------------------
void initSystem(void)
{
	//---------------------------------Inicio de Configuracion GPIOx---------------------------------

	//---------------------------BlinkyLed--------------------------------
	//---------------PIN: PA5----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_BlinkyPin.pGPIOx = GPIOA;
	//Definimos el pin a utilizar
	handler_GPIO_BlinkyPin.GPIO_PinConfig.GPIO_PinNumber = PIN_5; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_BlinkyPin, GPIO_MODE_OUT, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_BlinkyPin);

	//---------------------------Button-------------------------------
	//---------------PIN: PC13----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_Button.pGPIOx = GPIOC;
	//Definimos el pin a utilizar
	handler_GPIO_Button.GPIO_PinConfig.GPIO_PinNumber = PIN_13; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_Button, GPIO_MODE_OUT, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_Button);

	//-------------------------PIN_MCO2--------------------------------
	//---------------PIN: PC9----------------
	//------------AF0: MCO_2----------------
	//Definimos el periferico GPIOx a usar.
	handler_GPIO_MCO2.pGPIOx = GPIOC;
	//Definimos el pin a utilizar
	handler_GPIO_MCO2.GPIO_PinConfig.GPIO_PinNumber = PIN_9; 						//PIN_x, 0-15
	//Definimos la configuracion de los registro para el pin seleccionado
	// Orden de elementos: (Struct, Mode, Otyper, Ospeedr, Pupdr, AF)
	GPIO_PIN_Config(&handler_GPIO_MCO2, GPIO_MODE_ALTFN, GPIO_OTYPER_PUSHPULL, GPIO_OSPEEDR_MEDIUM, GPIO_PUPDR_NOTHING, AF0);
	/*Opciones: GPIO_Tipo_x, donde x--->||IN, OUT, ALTFN, ANALOG ||| PUSHPULL, OPENDRAIN |||
	 * ||| LOW, MEDIUM, FAST, HIGH ||| NOTHING, PULLUP, PULLDOWN, RESERVED |||  AFx, 0-15 |||*/
	//Cargamos la configuracion del PIN especifico
	GPIO_Config(&handler_GPIO_MCO2);

	//---------------------------------Fin de Configuracion GPIOx---------------------------------

}

//------------------------------Fin Configuracion del microcontrolador------------------------------------------


//------------------------------Inicio definicion de las funciones de las Taks-----------------------------------------

//Funcion que gobierna la Task BL
void vTask_blink_led( void * pvParameters )
{
	//Definicion de funciones de las
	 BaseType_t notify_state = 0;
	 uint8_t change_state = 0;

	while(1)
	{
		//Si se recibe una notifiacion se cambia la variable
		if(notify_state == pdTRUE)
		{
			change_state = !change_state;
		}
		//Deacuerdo al valor de la variable se cambia el valor del pin del LED
		if(change_state == 1)
		{
			GPIOxTooglePin(&handler_GPIO_BlinkyPin);
		}
		else
		{
			GPIO_writePin(&handler_GPIO_BlinkyPin, RESET);
		}
		//Recepccion de notificacion, la tarea entra en estado de bloqueo esperando por una notificacion
		notify_state = xTaskNotifyWait(0  0 ,NULL, pdMS_TO_TICKS(250);
	}
}

/* Funcion que gobierna a la tarea 2*/
void vTaskTwo( void * pvParameters )
{
	int8_t button_state = 0;
	uint8_t prev_button_state = 0;
	while(1)
	{
		button_state =  GPIO_RedPin (&handler_GPIO_Button);
		if(button_state==1)
		{
			if(!prev_button_state)
			{
				xTaskNotify(xHandleTaskBL,0,eNoAction);
			}
		}

		prev_button_state = button_state;

		vTaskDelay(pdMS_TO_TICKS(10));
	}
}
//------------------------------Fin definicion de las funciones de las Taks-----------------------------------------

